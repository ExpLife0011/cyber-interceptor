/*++

Copyright (c) 
 
Module Name:
 
    cybersys.c

Abstract:

    This framework is generated by QuickSYS 0.4

Author:

	<your name>

Environment:

	Kernel mode only.

Revision History:

	N.B.
	__except_handler4 is used by VC8 if BufferSecurityCheck(/GS) is on, supported by WDK.
	Turn it off when using old DDK and VC8 will use __except_handler3.

	If BufferSecurityCheck(/GS) is on, change entry point to GsDriverEntry@8 and add BufferOverflowK.lib.

	For x64, change _X86_=1 to _AMD64=1, include directory to ddk\wnet, lib path to lib\wnet\amd64.

--*/

#include "precomp.h"
#include "cybersys.h"

//
// A structure representing the instance information associated with
// a particular device
//



#include "all_header.h"



//////////////////////////////////////////////////////////////////////////


PDRIVER_OBJECT	g_pDriverObject	=	NULL;
PVOID			g_ObjectUdpWorkItemThread=NULL;



//
// Device driver routine declarations.
//

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	);

NTSTATUS
CybersysDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
CybersysDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

NTSTATUS
CybersysDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	);

VOID
CybersysUnload(
	IN PDRIVER_OBJECT		DriverObject
	);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CybersysDispatchCreate)
#pragma alloc_text(PAGE, CybersysDispatchClose)
#pragma alloc_text(PAGE, CybersysDispatchDeviceControl)
#pragma alloc_text(PAGE, CybersysUnload)
#endif // ALLOC_PRAGMA


NTSTATUS Init(PDRIVER_OBJECT pDriverObj)
{
	NTSTATUS		status = STATUS_SUCCESS;
	ADAPTER_INFOEX	*pAIEX=NULL;
	ULONG			size2take;
	int uCounter;
	HANDLE			hThread=NULL;

	//网卡信息模块
	InitializeListHead(&g_NetCardsInfoHeader.Next);//
	KeInitializeSpinLock(&g_NetCardsInfoLock);
	//ExInitializeResourceLite(&g_NetCardsInfoLock);
	//g_NetCardsInfoHeader.pLock	=	&g_NetCardsInfoLock;

	//miniport hook模块
	InitializeListHead(&g_pHookInfoHeader.Next);//
	NdisInitializeReadWriteLock(&g_HookInfoLock2);


	//重定向
	InitializeListHead(&g_RedirectInfo.Next);	
	//KeInitializeSpinLock(&g_RedirectInfoLock);
	NdisInitializeReadWriteLock(&g_RedirectInfoLock2);


	//发送数据模块
	KeInitializeSpinLock(&g_SendPacketListLock);
	KeInitializeEvent(&g_SendPacketListEvent,SynchronizationEvent,FALSE);
	InitializeListHead(&g_SendPacketListHeader);

	//wireshark模块
	InitializeListHead(&g_WSPacketList.Next);
	KeInitializeSpinLock(&g_WSPacketListLock);
	KeInitializeEvent(&g_WSPacketListEvent,SynchronizationEvent,FALSE);

	//防火墙模块
	InitFW();
	status	=	InitMiniPortHook();
	if (!NT_SUCCESS(status))
	{
		return status;
	}

	status	 = PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL,NULL, UdpWorkItemThread, pDriverObj);
	if (!NT_SUCCESS(status))
	{
		kprintf("fals on PsCreateSystemThread ,are u fucking kidding me??\n");
	}
	else
	{
		status = ObReferenceObjectByHandle(hThread, THREAD_ALL_ACCESS, *PsThreadType, KernelMode, &g_ObjectUdpWorkItemThread, NULL);
		if (!NT_SUCCESS(status))
		{
			kprintf("come on ,ObReferenceObjectByHandle fail!???? 0x%x\n",status);
			g_ObjectUdpWorkItemThread	=	NULL;
		}
		ZwClose(hThread);
	}

	return status;

}
//////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT		DriverObject,
	IN PUNICODE_STRING		RegistryPath
	)
{
	NTSTATUS			status;    
    UNICODE_STRING		ntDeviceName;
	UNICODE_STRING		dosDeviceName;
    PDEVICE_EXTENSION	deviceExtension;
	PDEVICE_OBJECT		deviceObject = NULL;
	BOOLEAN				symbolicLink = FALSE;

	//KdBreakPoint();

    dprintf("[cybersys] DriverEntry: %wZ\n", RegistryPath);

	g_pDriverObject	=	DriverObject;

    //
    // TODO:
    //
    //     1. Report it's resources (IoReportResourceUsage)
    //
    //     2. Attempt to locate the device(s) it supports
	//

    RtlInitUnicodeString(&ntDeviceName, CYBERSYS_DEVICE_NAME_W);

    status = IoCreateDevice(
		DriverObject,
		sizeof(DEVICE_EXTENSION),		// DeviceExtensionSize
		&ntDeviceName,					// DeviceName
		FILE_DEVICE_CYBERSYS,	// DeviceType
		0,								// DeviceCharacteristics
		TRUE,							// Exclusive
		&deviceObject					// [OUT]
		);

	if (!NT_SUCCESS(status))
	{
		dprintf("[cybersys] IoCreateDevice failed(0x%x).\n", status);
		goto failed;
	}

	deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

	//
	// TODO: set up synchronization objects, state info,, etc.
	//

    RtlInitUnicodeString(&dosDeviceName, CYBERSYS_DOS_DEVICE_NAME_W);

    status = IoCreateSymbolicLink(&dosDeviceName, &ntDeviceName);

    if (!NT_SUCCESS(status))
    {
        dprintf("[cybersys] IoCreateSymbolicLink failed(0x%x).\n", status);
		goto failed;
    }

	symbolicLink = TRUE;

	status = Init(DriverObject);

	g_CtlDevice	=	deviceObject;
	//
	// Create dispatch points for device control, create, close.
	//

	DriverObject->MajorFunction[IRP_MJ_CREATE]         = CybersysDispatchCreate;
	DriverObject->MajorFunction[IRP_MJ_CLOSE]          = CybersysDispatchClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CybersysDispatchDeviceControl;
	DriverObject->DriverUnload                         = CybersysUnload;

    if (NT_SUCCESS(status))
	    return status;

failed:

	if (symbolicLink)
		IoDeleteSymbolicLink(&dosDeviceName);

	if (deviceObject)
		IoDeleteDevice(deviceObject);

	return status;
}

NTSTATUS
CybersysDispatchCreate(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[cybersys] IRP_MJ_CREATE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
CybersysDispatchClose(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Information = 0;

	dprintf("[cybersys] IRP_MJ_CLOSE\n");

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
CybersysDispatchDeviceControl(
	IN PDEVICE_OBJECT		DeviceObject,
	IN PIRP					Irp
	)
{
	NTSTATUS			Status = STATUS_SUCCESS;
	PIO_STACK_LOCATION	irpStack;
	PDEVICE_EXTENSION	deviceExtension;
	PVOID				ioBuf;
	ULONG				inBufLength, outBufLength;
	ULONG				ioControlCode;
	ULONG_PTR			 num=0;

	irpStack = IoGetCurrentIrpStackLocation(Irp);
	deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	Irp->IoStatus.Information = 0;

	//
	// Get the pointer to the input/output buffer and it's length
	//

	ioBuf = Irp->AssociatedIrp.SystemBuffer;
	inBufLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
	outBufLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
	ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
	// Irp->UserBuffer;		// If METHOD_NEITHER, This is Output Buffer

	switch (ioControlCode)
	{
	case IOCTL_ADD_RIDIRECTINFO:
		{
			//
			if (AddOrDelInfo(ioBuf, inBufLength, TRUE)==FALSE)
			{
				Status	=	STATUS_UNSUCCESSFUL;
			}
			break;
		}
	case IOCTL_DEL_RIDIRECTINFO:
		{
			if (AddOrDelInfo(ioBuf, inBufLength, FALSE)==FALSE)
			{
				Status	=	STATUS_UNSUCCESSFUL;
			}
			break;
		}

	case IOCTL_SETUPFW:
	case IOCTL_UNSETFW:
	case IOCTL_PENDDINGCHECKPORT:
	case IOCTL_SETONEPORTSTATUS:
	case IOCTL_RESPONSEPORTASK:
	case IOCTL_ReleasePENDDINGCHECKPORT:
	case IOCTL_GETPORTSTATUS:
		{
			//防火墙模块
			Status	=	FWDispatch(DeviceObject, Irp);
			return Status;
		}

	case IOCTL_PATCHWS:
	case IOCTL_CHECKNPFSYS:
	case IOCTL_UNPATCHWS:
	case IOCTL_PATCH_NOSENTLOOPBACK:
	case IOCTL_PATCH_RESTORE_NOSENTLOOPBACK:
	case IOCTL_GETPROTOCOLLIST:

		{
			//Patch模块
			Status	=	PatchDispatch(DeviceObject, Irp);
			return Status;
		}



	case IOCTL_SEND_UDP:
		{

			IoMarkIrpPending(Irp);
			//这里的异步还没很好的支持
			ExInterlockedInsertHeadList(&g_SendPacketListHeader, &Irp->Tail.Overlay.ListEntry, &g_SendPacketListLock);
			KeSetEvent(&g_SendPacketListEvent, IO_NO_INCREMENT, FALSE );
			Status= STATUS_PENDING;
			return Status;
			//	Status	=	MiniportSendUdp(ioBuf, inBufLength);
			//break;
		}
	case IOCTL_FIX_GATEWAYMAC:
		{

			Status	=	FixGatewayMac(ioBuf, inBufLength);
			break;
		}
	case IOCTL_GPATHBYPID:
		{
			Status		=	GetProcessImagePath(*(PULONG)ioBuf, ioBuf, &outBufLength);
			if (Status==STATUS_INFO_LENGTH_MISMATCH)
			{
				Status	=	STATUS_SUCCESS;
			}
			Irp->IoStatus.Information=outBufLength;
			break;
		}
	case IOCTL_GET_TCPINFO:
	case IOCTL_GET_UDPINFO:
		{
			Status	=	EnumConnections(DeviceObject,Irp);
			return Status;
		}
	default:
		{

			//Status = STATUS_INVALID_PARAMETER;
			kprintf("Unknown IOCTL: 0x%X (%04X,%04X)\n",
				ioControlCode, DEVICE_TYPE_FROM_CTL_CODE(ioControlCode),
				IoGetFunctionCodeFromCtlCode(ioControlCode));


			break;
		}
	}


	Irp->IoStatus.Status = Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return Status;
}

VOID
CybersysUnload(
	IN PDRIVER_OBJECT		DriverObject
	)
{
	UNICODE_STRING dosDeviceName;
	kprintf("Enter Miniport_hookUnload \r\n");
	//
	// Free any resources
	//
	//
	// Delete the symbolic link
	//

	RtlInitUnicodeString(&dosDeviceName, CYBERSYS_DOS_DEVICE_NAME_W);

	IoDeleteSymbolicLink(&dosDeviceName);

	//
	// Delete the device object
	//



	//UDP模块
	//先把UDP包发送线程结束掉
	TerminateUdpWorkItemThread();
	if (g_ObjectUdpWorkItemThread)
	{
		KeWaitForSingleObject(g_ObjectUdpWorkItemThread,Executive,KernelMode,0,0);
		ObDereferenceObject (g_ObjectUdpWorkItemThread);
	}

	//miniport hook模块
	UnHook();


	//重定向模块
	ReleaseRedirectInfo();


	//网卡信息模块
	ReleaseNetCardsInfo();

	//防火墙模块释放
	UninitFW();

	//patch ws模块
	UnInitPatch();


	//删除设备
	IoDeleteDevice(g_CtlDevice);

	kprintf("Unloaded\n");

   // dprintf("[cybersys] unloaded\n");
}

